name: Generate and Update Code

on:
  # Schedules the workflow to run every hour on the hour
  schedule:
    - cron: '0 * * * *'

  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # ----------------------------------------------------------------------
  # 1. THE PLANNER AGENT: Determines the next task and outputs a JSON plan.
  # ----------------------------------------------------------------------
  planner:
    runs-on: ubuntu-latest
    outputs:
      plan_details: ${{ steps.plan-step.outputs.plan }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Install dependencies (Gemini CLI & JQ)
        run: |
          npm install -g @google/gemini-cli
          sudo apt-get install -y jq

      - name: Planner Agent:Generate Task Plan
        id: plan-step
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          PLANNER_PROMPT=$(cat <<EOF
          SYSTEM: You are the Planner Agent. Your job is to read the site direction (GEMINI.MD, if it exists) and the current code (index.html), and propose one *minimal, specific, and self-contained* improvement. 
          
          You must output *only* a single JSON object. DO NOT include any text outside the JSON block. Your goal is to guide the site toward the goals in GEMINI.MD. Prioritize technical debt, UI/UX improvements, or small, interesting feature additions.
          
          The output JSON must strictly follow this format: 
          {
            "task_found": true, 
            "feature_name": "A concise, 5-word title for the change (e.g., 'Implement Dark Mode Toggle')",
            "description": "A detailed, technical description of the exact files and code changes required. Must be precise.",
            "files_to_change": ["index.html"]
          }
          
          If you cannot find a suitable task, respond with "task_found: false".
          EOF
          )

          # Pass files and the system prompt to Gemini
          gemini "$PLANNER_PROMPT" -f GEMINI.MD index.html \
            -m $GEMINI_MODEL -o json --yolo > plan_output.json

          # Extract the JSON response and check for task_found: true
          PLAN_JSON=$(jq -r '.response' plan_output.json)
          echo "PLAN_JSON: $PLAN_JSON"
          
          # Save the plan for downstream jobs
          echo "$PLAN_JSON" > plan.json
          
          # Set the plan as an output for job dependency
          echo "plan=$PLAN_JSON" >> $GITHUB_OUTPUT

      - name: Upload Plan Artifact
        uses: actions/upload-artifact@v4
        with:
          name: evolution-plan
          path: plan.json
          
  update-repo:
    needs: planner
    if: fromJson(needs.planner.outputs.plan_details).task_found == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.BOT_PAT }}

      - name: Install Gemini CLI
        run: npm install -g @google/gemini-cli

      - name: Generate updated code with Gemini
        id: generate-code
        run: |
          PLAN_DESCRIPTION=$(echo $PLAN_JSON | jq -r '.description')
          # Use Gemini CLI to generate or update content
          # This example generates a simple greeting and saves it to a file.
          # The '--yolo' flag bypasses prompts, which is essential for automation.
          gemini \
            'Always use GEMINI.MD instructions. Read the index.html. You will have to update it and return only the HTML content of the updated version.' \
            'Pick a random theme and choose one very interesting fact from it. The site should display that interesting fact.' \
            'It should also choose the best matching color for the fact and use it as a background color for the website.' \
            'It should also choose text color for the text to be clearly visible. Updated the footer color to also be clearly visible.' \
            'Review the UI/UX and improve it.'  \
            'Make the UI clean and emphasize what is essential.' \
            'Use the plan to implement it.' \
            'Plan: $PLAN_DESCRIPTION' \
            -m gemini-2.5-flash \
            -o json \
            --yolo > output.json

          # Print the response for debugging purposes.
          cat output.json

          # Extract the content from the JSON output and save to a file.
          # You will need to parse the JSON output to get the generated code.
          jq -r '.response' output.json > index.html
          
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PLAN_JSON: ${{ needs.planner.outputs.plan_details }}

      - name: Read and Clean index.html
        id: cleanup_html
        uses: actions/github-script@v7
        with:
          # Set the script to run Node.js code
          script: |
            const fs = require('fs');
            const filePath = './index.html'; // Path to your file
      
            // 1. Read the file content
            if (!fs.existsSync(filePath)) {
                core.setFailed(`File not found: ${filePath}`);
                return;
            }
            let dirtyHtml = fs.readFileSync(filePath, 'utf8');
      
            // 2. Define the cleanup Regular Expression
            // /<!doctype[\s\S]*?<\/html>/i
            // - i: case-insensitive
            // - [\s\S]*?: matches any character (including newlines) non-greedily
            const regex = /<!doctype[\s\S]*?<\/html>/i;
      
            // 3. Match and Extract the clean HTML
            const match = dirtyHtml.match(regex);
      
            if (match) {
                const cleanHtml = match[0];
                console.log(`Successfully extracted clean HTML (${cleanHtml.length} characters).`);
                
                // 4. Overwrite the file with the clean content
                fs.writeFileSync(filePath, cleanHtml, 'utf8');
                
                // Optional: Set the clean content as a step output as well
                core.setOutput('clean_html', cleanHtml);
            } else {
                core.setFailed("Could not find a complete <!doctype...</html> block in index.html.");
            }

      - name: Commit and push changes
        run: |
          # Make sure the bot is configured correctly
          git config --local user.email "automatogreenhouse@gmail.com"
          git config --local user.name "Automato"
          
          # Stage the file.
          git add index.html
          
          # Check if there are changes to commit
          if ! git diff-index --quiet HEAD --; then
            git commit -m "feat: Automated commit from self-ai-update workflow"
            git push # Push the changes to the repository
          else
            echo "No changes to commit."
          fi
