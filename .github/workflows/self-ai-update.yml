name: Generate and Update Code

on:
  # Schedules the workflow to run every hour on the hour
  schedule:
    - cron: '0 * * * *'

  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  update-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.BOT_PAT }}

      - name: Install Gemini CLI
        run: npm install -g @google/gemini-cli

      - name: Generate updated code with Gemini
        id: generate-code
        run: |
          # Use Gemini CLI to generate or update content
          # This example generates a simple greeting and saves it to a file.
          # The '--yolo' flag bypasses prompts, which is essential for automation.
          gemini 'Read the index.html. You will have to update it and return only the HTML content of the updated version. Pick a random theme and choose one very interesting fact from it. The site should display that interesting fact. It should also choose the best matching color for the fact and use it as a background color for the website. It should also choose text color for the text to be clearly visible. Updated the footer color to also be clearly visible. Think about a small interesting feature that you could add. If it seems worth, add it too.' -m gemini-2.5-flash -o json --yolo > output.json

          # Print the response for debugging purposes.
          cat output.json

          # Extract the content from the JSON output and save to a file.
          # You will need to parse the JSON output to get the generated code.
          jq -r '.response' output.json > index.html
          
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}

      - name: Read and Clean index.html
        id: cleanup_html
        uses: actions/github-script@v7
        with:
          # Set the script to run Node.js code
          script: |
            const fs = require('fs');
            const filePath = './index.html'; // Path to your file
      
            // 1. Read the file content
            if (!fs.existsSync(filePath)) {
                core.setFailed(`File not found: ${filePath}`);
                return;
            }
            let dirtyHtml = fs.readFileSync(filePath, 'utf8');
      
            // 2. Define the cleanup Regular Expression
            // /<!doctype[\s\S]*?<\/html>/i
            // - i: case-insensitive
            // - [\s\S]*?: matches any character (including newlines) non-greedily
            const regex = /<!doctype[\s\S]*?<\/html>/i;
      
            // 3. Match and Extract the clean HTML
            const match = dirtyHtml.match(regex);
      
            if (match) {
                const cleanHtml = match[0];
                console.log(`Successfully extracted clean HTML (${cleanHtml.length} characters).`);
                
                // 4. Overwrite the file with the clean content
                fs.writeFileSync(filePath, cleanHtml, 'utf8');
                
                // Optional: Set the clean content as a step output as well
                core.setOutput('clean_html', cleanHtml);
            } else {
                core.setFailed("Could not find a complete <!doctype...</html> block in index.html.");
            }

      - name: Commit and push changes
        run: |
          # Make sure the bot is configured correctly
          git config --local user.email "automatogreenhouse@gmail.com"
          git config --local user.name "Automato"
          
          # Stage the file.
          git add index.html
          
          # Check if there are changes to commit
          if ! git diff-index --quiet HEAD --; then
            git commit -m "feat: Automated commit from self-ai-update workflow"
            git push # Push the changes to the repository
          else
            echo "No changes to commit."
          fi
